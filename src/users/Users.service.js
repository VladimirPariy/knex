const config = require("../database/knexConfig.js");const knex = require('knex')(config);const createRandomUser = require("../faker/faker");class UsersService {	async getAll() {		return await knex.select('*').from('users');	}	async createNew() {		return await knex.insert([createRandomUser()]).into('users');	}	async patchOne(id, data) {		return await knex('users').where({_id: id}).update(data);	}	async deleteOne(id) {		return await knex('users').where({_id: id}).del();	}	async batchInsert() {		const rows = [];		for (let i = 0; i < 1000; i++) {			rows.push(createRandomUser());		}		return await knex.batchInsert('users', rows) // 3d arg - chunkSize			.returning('*');	}	async batchUpdate(data) {		const users = await this.getAll();		return await knex.transaction(trx => {			const queries = [];			users.forEach(user => {				const query = knex('users')					.where('_id', user._id)					.update(data)					.transacting(trx); // This makes every update be in the same transaction				queries.push(query);			});			Promise.all(queries) // Once every query is written				.then(trx.commit) // We try to execute all of them				.catch(trx.rollback); // And rollback in case any of them goes wrong		});	}}module.exports = new UsersService()